# CS-320-Software-Automation-
This is an example of what I learned in this class

My testing approach for each of the features had the same basic outline. First, I would identify the restrictions. For the contract object the requirements where contact ID cannot be longer than 10 characters, cannot be null and cannot be updateable. The contract object will have a first name string and last name string that are each no longer than 10 characters and both will not be null. My tests would be based on these parameters and would throw an error if the contact was null or grater than 10 characters, if the first or last name was null or longer than 10 characters.  Each Class had its own restrictions, and I would test for each of these limitations within each class. Using this basic outline, I can expand this theory across all the classes because they all had similar elements, however those elements would change just slightly. For example, the contact object has a required address field however this string must be no longer than 30 characters as well as not be null. This being very similar to other classes it was easy to figure out how to accommodate for this small but important detail change. The over all quality of my Junit tests were effective because they had a 100% test result. I know they were effective because I would hard code errors for the Junit to pick up like having a first name longer than 10 characters and the error would get thrown. 
	My experience with the Junit tests was complicated in the beginning. I did not grasp the concept that to throw an error it would be best to try to break the code. For example, to test if a name is to long, hard code something that was longer than the code allowed and insert it into the field where it would not match the required parameters. By this I mean code a last name longer than 10 characters and have the error be thrown. If we look at the example below, we can see how my theory on this has evolved from when I began this class. I don’ think my code was as efficient as it could be early on in my project. However after gaining more experience with it I learned that hard coding the parameters I was testing against not only made my code more efficient but also would allow me to use it in other cases depending on the requirement changes.
 
	As we can see I hard coded the exceptions here for variables like “to long ID” or “to long description”. However after working on the project I realized I should make these parameters variables in case they change down the road, making it easier for code revisions. 

 
The first option is better because if the parameters change, say we have to shorten the description from 50 characters to 30, it would be easy to change rather than go back and change each variable individually. Some software techniques that I did not use for this project would be making sure an e-mail address had the “@” symbol in it. This was not relevant for my project because none of the fields required an e-mail address however the theory that could check a specific string for a specific character would be beneficial in a few cases, email being one of them.
	Being able to hard code your testing parameters to variables that are interchangeable and that aren’t can be greatly beneficial. Let’s say you are coding the “username” and “password” requirements for your Google account. We want to make sure the username is a certain length, and the password is strong enough. We can set specific testing variables for this ensuring the security of the code and the sure. Now flash forward 10 years when Google has changed its log in to not only accept a username but your cell phone as well. Being able to go in and change these parameters would be great, and you do not have to rewrite the entire program. As well has not having to change the parameters of the password. If we look at my pictures above the first picture would be a terrible mess to try and update because I hard coded all the variables to check against not taking into consideration the parameters might change one day. If we used the example from the second picture update this requirement would be a lot easier. 
	The mindset I adopted working on this project was adaptability. AS I have expressed before making the code easier to modify to test against specific parameters makes it a lot easier. As I am writing this now, I am thinking it would even be best to have variables for specific lengths to test against, like 10 characters or 30. That was if we wanted to change these lengths, we can just refactor the code and modify it within minutes. This would be beneficial, so we don’t have to go through 100’s of lines of code to change a few requirements and we might even miss a few, because we are human, and we make mistakes. This is one example of how I am not bias towards my own code. We are all learning and trying to become better developers as we learn about Junit and testing requirements for each code. There’s always room to grow and become a better developer, you just have to be open to new paths of learning. I think I was over cautious in the being of testing Junit tests to make sure I was through. However, I realize now that my code might be to long or just not as efficient as it could be. It is important to appreciate the complexity and interrelationships of the code as I have mentioned to hardcode variables with certain parameters as I did towards the end of my development. The complexity of this assignment was in my opinion extremely basic given the scope of all the technology around use and varying different access levels. Just the example I used above where your access name might be tied to either a cell phone or a username. This would trigger different tests all together, are there numbers only did the user use parentheses or dashes. Does the user have the same password for different access methods? The list goes on and on and I can only image the requirements for checking these parameters
	It is extremely important to be disciplined in your commitment to quality as a software engineering professional. You are the last line of defense, you are the gate keeper, the double checker, the wall that keeps all the information and access safe and secure. We must be vigilant in not only building code but testing it. It is a bad idea to assume that the tester will catch or change an error just as much as it is a bad idea to assume the developer was right without verifying their code. When writing code, you must remain focused as make sure every t is crossed and every I is dotted. The same goes for the tester though, you can never assume one knows more or is better than the other. We all make mistakes and overlook things sometimes so when doing our job tester or developer we must practice the best industry standards as well as stay secure. The way I plan on avoiding technical debt as a practitioner in the field would be to constantly try to become better and more efficient at writing code. For example, even in this class as we evolved and learned more about testing, I got better and better with each assignment. I would ask senior member of the team if there were better ways to execute testing then the ones I have though of. Technical debt otherwise known as prioritizing client value, intentionally or unintentionally is hard to depict. On one hand you want the customer or client to be happy, on the other if certain specifications are taking longer than expected this can cause frustration and even have the project take more time. The way I would plan on avoiding this is to be honest with the client from the being about the testing process. Sometimes it goes smoothly and sometimes it does. However, either way it goes it is always best to try and be thorough in the development process, rather than top try and play catch up by releasing code that is not safe or secure. We can look at our reading for specific examples, from the satellite to the fighter Jet. However unintentional these software glitches are they have costed millions of dollars and have the potential to threaten human life. 
